#include <iostream>
#include <conio.h>
#include <Windows.h>

using namespace std;

// const можно использовать в качестве дискриминатора двух функций
void fn(const int& nVar);
void fn(int& nVar);

int main(int argc, char* argv[])
{
    SetConsoleCP(1251);
    SetConsoleOutputCP(1251);

    const double PI = 3.14;                                                     // константа неизменяема!!!

    // А как же обстоит дело с константными указателями?

    // Первый случай - это объявление указателя на константную ячейку памяти

    int num = 0;
    // убрать const, чтобы работало
    const int* pNum = &num;                                                     // объявление указателя на константную ячейку памяти
    cout << "Значение указателя = " << *pNum << endl;
    pNum++;                                                                     // арифметика указателей допустима с указателя на константную ячейку памяти
    cout << "Значение указателя = " << *pNum << endl;

    // А вот изменение значения по указателю запрещено!

    *pNum = 10;                                                                 // Этот код вызывает ошибку!!!
    cout << "Значение указателя = " << *pNum << endl;

    // Обратная ситуация от вышеописанного - это объявление константного указателя

    int num1 = 100;
    int* const pNum1 = &num1;                                                   // объявление константного указателя
    cout << "Значение указателя = " << *pNum1 << endl;
    // закоментировать эту и следующие строки, чтобы работало
    pNum1++;                                                                    // арифметика указателей НЕ допустима с константным указателем!!!
    cout << "Значение указателя = " << *pNum1 << endl;
                                                                                // А вот изменения значения по указателю запрещено!
    *pNum1 = 200;                                                               // Теперь это работает!!!
    cout << "Значение указателя = " << *pNum1 << endl;

    // Избавиться от константности указателя простого пути нет

    int var = 0;
    const int* pVar = &var;
    // закоментировать, чтобы работало
    int* pVar2 = pVar;                                                          // Присвоить обычному указателю константный не получится!



    int n = 0;
    fn(5);
    fn(n);                                                                      // переменная может неявно приводиться к const при вызове функции

    getch();

    return 0;
}

void fn(const int& nVar)
{
    nVar = 10;                                                                  // этот код вызовет ошибку. Константу нельзя изменять!!!
}

void fn(int& nVar)
{
    nVar = 20;
}
